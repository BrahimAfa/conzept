"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeTree = void 0;
var getFromMap_1 = require("./getFromMap");
var last_1 = require("./last");
var normalizeTree = function (root, accessor, settings, map) {
    var targets = getFromMap_1.getFromMap(root[accessor], map);
    if (!targets || !targets.length)
        return;
    var firstTargetSiblings = getFromMap_1.getFromMap(targets[0][settings.nextBeforeAccessor], map);
    var firstMostNode = (firstTargetSiblings === null || firstTargetSiblings === void 0 ? void 0 : firstTargetSiblings[0]) || targets[0];
    var lastTarget = last_1.last(targets);
    var lastTargetPartner = last_1.last(getFromMap_1.getFromMap(lastTarget[settings.nextAfterAccessor], map));
    var lastMostNode = lastTargetPartner || lastTarget;
    var shift;
    if (settings.orientation === "vertical") {
        var centerPointX = (firstMostNode.x + lastMostNode.x + lastMostNode.width) / 2;
        var rootCenterX = root.x + root.width / 2;
        shift = centerPointX - rootCenterX;
        targets.forEach(function (node) {
            normalizeTargetsX(node);
        });
    }
    else {
        var centerPointY = (firstMostNode.y + lastMostNode.y + lastMostNode.height) / 2;
        var rootCenterY = root.y + root.height / 2;
        shift = centerPointY - rootCenterY;
        targets.forEach(function (node) {
            normalizeTargetsY(node);
        });
    }
    function normalizeTargetsX(subtree) {
        var _a, _b, _c;
        subtree.x -= shift;
        (_a = getFromMap_1.getFromMap(subtree[settings.nextBeforeAccessor], map)) === null || _a === void 0 ? void 0 : _a.forEach(function (sibling) {
            sibling.x -= shift;
        });
        (_b = getFromMap_1.getFromMap(subtree[settings.nextAfterAccessor], map)) === null || _b === void 0 ? void 0 : _b.forEach(function (partner) {
            partner.x -= shift;
        });
        (_c = getFromMap_1.getFromMap(subtree[accessor], map)) === null || _c === void 0 ? void 0 : _c.forEach(function (node) {
            normalizeTargetsX(node);
        });
    }
    function normalizeTargetsY(subtree) {
        var _a, _b, _c;
        subtree.y -= shift;
        (_a = getFromMap_1.getFromMap(subtree[settings.nextBeforeAccessor], map)) === null || _a === void 0 ? void 0 : _a.forEach(function (sibling) {
            sibling.y -= shift;
        });
        (_b = getFromMap_1.getFromMap(subtree[settings.nextAfterAccessor], map)) === null || _b === void 0 ? void 0 : _b.forEach(function (partner) {
            partner.y -= shift;
        });
        (_c = getFromMap_1.getFromMap(subtree[accessor], map)) === null || _c === void 0 ? void 0 : _c.forEach(function (node) {
            normalizeTargetsY(node);
        });
    }
};
exports.normalizeTree = normalizeTree;
//# sourceMappingURL=normalizeTree.js.map