"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromMap = void 0;
var addTargetNodesSize_1 = require("./addTargetNodesSize");
var centerSourceToTargets_1 = require("./centerSourceToTargets");
var checkContourOverlap_1 = require("./checkContourOverlap");
var defaultSettings_1 = require("./defaultSettings");
var getElements_1 = require("./getElements");
var getFromMap_1 = require("./getFromMap");
var getGenerationBottomLineY_1 = require("./getGenerationBottomLineY");
var getGenerationMaxHeight_1 = require("./getGenerationMaxHeight");
var getGenerationTopLineY_1 = require("./getGenerationTopLineY");
var getInitialTargetsShiftLeft_1 = require("./getInitialTargetsShiftLeft");
var normalizeTree_1 = require("./normalizeTree");
function fromMap(rootId, originalMap, customSettings) {
    if (customSettings === void 0) { customSettings = {}; }
    var settings = __assign(__assign({}, defaultSettings_1.defaultSettings), customSettings);
    var map = settings.clone
        ? JSON.parse(JSON.stringify(originalMap))
        : originalMap;
    var root = map[rootId];
    root.x = settings.rootX;
    root.y = settings.rootY;
    root.isRoot = true;
    addTargetNodesSize_1.addTargetNodesSize([root], settings, map);
    root.topLineY = root.y;
    root.bottomLineY = root.y + root.height + root.marginBottom;
    if (root[settings.siblingsAccessor])
        getFromMap_1.getFromMap(root[settings.siblingsAccessor], map)
            .reverse()
            .forEach(function (sibling, siblingIndex, rootSiblings) {
            sibling.source = root;
            var nextNode = rootSiblings[siblingIndex - 1] || root;
            sibling.x = nextNode.x - sibling.width - sibling.marginRight;
            //align vertically
            sibling.y = root.y + root.height / 2 - sibling.height / 2;
            var outerBottomY = sibling.y + sibling.height + sibling.marginBottom;
            if (sibling.y < root.topLineY)
                root.topLineY = sibling.y;
            if (outerBottomY > root.bottomLineY)
                root.bottomLineY = outerBottomY;
        });
    if (root[settings.partnersAccessor])
        getFromMap_1.getFromMap(root[settings.partnersAccessor], map).forEach(function (partner, partnerIndex, rootPartners) {
            partner.source = root;
            var previousPartner = rootPartners[partnerIndex - 1] || root;
            partner.x =
                previousPartner.x +
                    previousPartner.width +
                    previousPartner.marginRight;
            partner.y = root.y + root.height / 2 - partner.height / 2;
            var outerBottomY = partner.y + partner.height + partner.marginBottom;
            if (partner.y < root.topLineY)
                root.topLineY = partner.y;
            if (outerBottomY > root.bottomLineY)
                root.bottomLineY = outerBottomY;
        });
    var descendantsContour = [];
    drillChildren(root);
    function drillChildren(subtree) {
        var children = getFromMap_1.getFromMap(subtree[settings.childrenAccessor], map);
        if (!children || !children.length)
            return;
        //rename to addGenerationSizes
        addTargetNodesSize_1.addTargetNodesSize(children, settings, map);
        var initialShiftLeft = getInitialTargetsShiftLeft_1.getInitialTargetsShiftLeft(subtree, children, settings, map);
        var currentX = subtree.x - initialShiftLeft;
        var topLineY = getGenerationBottomLineY_1.getGenerationBottomLineY(subtree, settings, map);
        children.forEach(function (child) {
            var maxHeight = getGenerationMaxHeight_1.getGenerationMaxHeight(child, settings, map);
            var midVerticalY = topLineY + maxHeight / 2;
            /////////////////// SIBLING
            var siblings = getFromMap_1.getFromMap(child[settings.siblingsAccessor], map);
            siblings === null || siblings === void 0 ? void 0 : siblings.forEach(function (sibling) {
                sibling.isSibling = true;
                //sibling.source = child; ??
                sibling.x = currentX;
                sibling.y = midVerticalY - sibling.height / 2;
                checkContourOverlap_1.checkContourOverlap(descendantsContour, sibling);
                currentX = sibling.x + sibling.width + sibling.marginRight;
            });
            /////////////////// CHILD
            //set props
            child.isDescendant = true;
            //set the parent pointer
            //child.sourceId = subtree.id; ??
            //Set positions
            child.x = currentX;
            child.y = midVerticalY - child.height / 2;
            checkContourOverlap_1.checkContourOverlap(descendantsContour, child);
            currentX = child.x + child.width + child.marginRight;
            /////////////////// partners
            var partners = getFromMap_1.getFromMap(child[settings.partnersAccessor], map);
            partners === null || partners === void 0 ? void 0 : partners.forEach(function (partner) {
                partner.isPartner = true;
                //partner.source = child; ??
                partner.x = currentX;
                partner.y = midVerticalY - partner.height / 2;
                checkContourOverlap_1.checkContourOverlap(descendantsContour, partner);
                currentX = partner.x + partner.width + partner.marginRight;
            });
            drillChildren(child);
        });
        centerSourceToTargets_1.centerSourceToTargets(subtree, children, settings, map);
    }
    normalizeTree_1.normalizeTree(root, settings.childrenAccessor, settings, map);
    var parentsContour = [];
    drillParents(root);
    function drillParents(subtree) {
        var parents = getFromMap_1.getFromMap(subtree[settings.parentsAccessor], map);
        if (!(parents === null || parents === void 0 ? void 0 : parents.length))
            return;
        addTargetNodesSize_1.addTargetNodesSize(parents, settings, map);
        var initialShiftLeft = getInitialTargetsShiftLeft_1.getInitialTargetsShiftLeft(subtree, parents, settings, map);
        var currentX = subtree.x - initialShiftLeft;
        var bottomLineY = getGenerationTopLineY_1.getGenerationTopLineY(subtree, settings, map);
        parents.forEach(function (parent) {
            var _a;
            var maxHeight = getGenerationMaxHeight_1.getGenerationMaxHeight(parent, settings, map);
            var midVerticalY = bottomLineY - settings.verticalSpacing - maxHeight / 2;
            /////////////////// SIBLING
            var siblings = getFromMap_1.getFromMap(parent[settings.siblingsAccessor], map);
            siblings === null || siblings === void 0 ? void 0 : siblings.forEach(function (sibling) {
                sibling.isSibling = true;
                //sibling.source = parent; ??
                sibling.x = currentX;
                sibling.y = midVerticalY - sibling.height / 2;
                checkContourOverlap_1.checkContourOverlap(parentsContour, sibling);
                currentX = sibling.x + sibling.width + sibling.marginRight;
            });
            ///////////// PARENT
            parent.isAncestor = true;
            //parent.source = subtree; ??
            //set positions
            parent.x = currentX;
            parent.y = midVerticalY - parent.height / 2;
            //check if touches one of the contours
            checkContourOverlap_1.checkContourOverlap(parentsContour, parent);
            currentX = parent.x + parent.width + parent.marginRight;
            /////////////////// partners
            (_a = parent[settings.partnersAccessor]) === null || _a === void 0 ? void 0 : _a.forEach(function (partner) {
                partner.isPartner = true;
                //partner.source = parent; ??
                partner.x = currentX;
                partner.y = midVerticalY - partner.height / 2;
                checkContourOverlap_1.checkContourOverlap(parentsContour, partner);
                currentX = partner.x + partner.width + partner.marginRight;
            });
            drillParents(parent);
        });
        centerSourceToTargets_1.centerSourceToTargets(subtree, parents, settings, map);
    }
    normalizeTree_1.normalizeTree(root, settings.parentsAccessor, settings, map);
    return getElements_1.getElements(root, settings, map);
}
exports.fromMap = fromMap;
//# sourceMappingURL=fromMap.js.map