"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.drillParents = void 0;
var addGroupLeftX_1 = require("./addGroupLeftX");
var addGroupTopY_1 = require("./addGroupTopY");
var addLevelNodesSizes_1 = require("./addLevelNodesSizes");
var centerSourceToTargets_1 = require("./centerSourceToTargets");
var checkContourOverlap_1 = require("./checkContourOverlap");
var getFromMap_1 = require("./getFromMap");
var getInitialTargetsShiftLeft_1 = require("./getInitialTargetsShiftLeft");
var getInitialTargetsShiftTop_1 = require("./getInitialTargetsShiftTop");
var getNodeBottomY_1 = require("./getNodeBottomY");
var getNodeRightX_1 = require("./getNodeRightX");
var parentsContour = [];
function drillParents(subtree, settings, map) {
    var parents = getFromMap_1.getFromMap(subtree[settings.sourcesAccessor], map);
    if (!(parents === null || parents === void 0 ? void 0 : parents.length))
        return;
    addLevelNodesSizes_1.addLevelNodesSizes(parents, settings, map);
    if (settings.orientation === "vertical") {
        var initialShiftLeft = getInitialTargetsShiftLeft_1.getInitialTargetsShiftLeft(subtree, parents, settings, map);
        var currentX_1 = subtree.x - initialShiftLeft;
        parents.forEach(function (parent) {
            var _a, _b;
            var midVerticalY = subtree.groupTopY -
                settings.sourceTargetSpacing -
                parent.groupMaxHeight / 2;
            /////////////////// BEFORES ///////////////////
            (_a = getFromMap_1.getFromMap(parent[settings.nextBeforeAccessor], map)) === null || _a === void 0 ? void 0 : _a.forEach(function (sibling) {
                sibling.x = currentX_1;
                sibling.y = midVerticalY - sibling.height / 2;
                checkContourOverlap_1.checkContourOverlap(parentsContour, sibling, settings);
                currentX_1 = getNodeRightX_1.getNodeRightX(sibling);
            });
            /////////////////// GROUP MAIN NODE ///////////////
            //set positions
            parent.x = currentX_1;
            parent.y = midVerticalY - parent.height / 2;
            //check if touches one of the contours
            checkContourOverlap_1.checkContourOverlap(parentsContour, parent, settings);
            currentX_1 = getNodeRightX_1.getNodeRightX(parent);
            /////////////////// AFTERS ///////////////////
            (_b = getFromMap_1.getFromMap(parent[settings.nextAfterAccessor], map)) === null || _b === void 0 ? void 0 : _b.forEach(function (partner) {
                partner.x = currentX_1;
                partner.y = midVerticalY - partner.height / 2;
                checkContourOverlap_1.checkContourOverlap(parentsContour, partner, settings);
                currentX_1 = getNodeRightX_1.getNodeRightX(partner);
            });
            addGroupTopY_1.addGroupTopY(parent, settings, map);
            drillParents(parent, settings, map);
        });
    }
    else {
        var initialShiftTop = getInitialTargetsShiftTop_1.getInitialTargetsShiftTop(subtree, parents, settings, map);
        var currentY_1 = subtree.y - initialShiftTop;
        parents.forEach(function (parent) {
            var _a, _b;
            var midPointX = subtree.groupLeftX -
                settings.sourceTargetSpacing -
                parent.groupMaxWidth / 2;
            /////////////////// SIBLING
            (_a = getFromMap_1.getFromMap(parent[settings.nextBeforeAccessor], map)) === null || _a === void 0 ? void 0 : _a.forEach(function (sibling) {
                sibling.y = currentY_1;
                sibling.x = midPointX - sibling.width / 2;
                checkContourOverlap_1.checkContourOverlap(parentsContour, sibling, settings);
                //update currentY position
                currentY_1 = getNodeBottomY_1.getNodeBottomY(sibling);
            });
            /////////////////// GROUP MAIN NODE ///////////////
            //Set positions
            parent.y = currentY_1;
            parent.x = midPointX - parent.width / 2;
            checkContourOverlap_1.checkContourOverlap(parentsContour, parent, settings);
            //update currentY position
            currentY_1 = getNodeBottomY_1.getNodeBottomY(parent);
            /////////////////// SPOUSES
            (_b = getFromMap_1.getFromMap(parent[settings.nextAfterAccessor], map)) === null || _b === void 0 ? void 0 : _b.forEach(function (partner) {
                partner.y = currentY_1;
                partner.x = midPointX - partner.width / 2;
                checkContourOverlap_1.checkContourOverlap(parentsContour, partner, settings);
                //update currentY position
                currentY_1 = getNodeBottomY_1.getNodeBottomY(partner);
            });
            addGroupLeftX_1.addGroupLeftX(parent, settings, map);
            drillParents(parent, settings, map);
        });
    }
    centerSourceToTargets_1.centerSourceToTargets(subtree, parents, settings, map);
}
exports.drillParents = drillParents;
//# sourceMappingURL=drillParents.js.map