"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.drillChildren = void 0;
var addGroupBottomY_1 = require("./addGroupBottomY");
var addGroupRightX_1 = require("./addGroupRightX");
var addLevelNodesSizes_1 = require("./addLevelNodesSizes");
var centerSourceToTargets_1 = require("./centerSourceToTargets");
var checkContourOverlap_1 = require("./checkContourOverlap");
var getFromMap_1 = require("./getFromMap");
var getInitialTargetsShiftLeft_1 = require("./getInitialTargetsShiftLeft");
var getInitialTargetsShiftTop_1 = require("./getInitialTargetsShiftTop");
var getNodeBottomY_1 = require("./getNodeBottomY");
var getNodeRightX_1 = require("./getNodeRightX");
var descendantsContour = [];
function drillChildren(subtree, settings, map) {
    var children = getFromMap_1.getFromMap(subtree[settings.targetsAccessor], map);
    if (!(children === null || children === void 0 ? void 0 : children.length))
        return;
    addLevelNodesSizes_1.addLevelNodesSizes(children, settings, map);
    if (settings.orientation === "vertical") {
        var initialShiftLeft = getInitialTargetsShiftLeft_1.getInitialTargetsShiftLeft(subtree, children, settings, map);
        var currentX_1 = subtree.x - initialShiftLeft;
        children.forEach(function (child) {
            var _a;
            var midVerticalY = subtree.groupBottomY + child.groupMaxHeight / 2;
            /////////////////// BEFORES ///////////////////
            var siblings = getFromMap_1.getFromMap(child[settings.nextBeforeAccessor], map);
            siblings === null || siblings === void 0 ? void 0 : siblings.forEach(function (sibling) {
                sibling.x = currentX_1;
                sibling.y = midVerticalY - sibling.height / 2;
                checkContourOverlap_1.checkContourOverlap(descendantsContour, sibling, settings);
                currentX_1 = getNodeRightX_1.getNodeRightX(sibling);
            });
            /////////////////// GROUP MAIN NODE
            //Set positions
            child.x = currentX_1;
            child.y = midVerticalY - child.height / 2;
            checkContourOverlap_1.checkContourOverlap(descendantsContour, child, settings);
            currentX_1 = getNodeRightX_1.getNodeRightX(child);
            /////////////////// AFTERS ///////////////////
            (_a = getFromMap_1.getFromMap(child[settings.nextAfterAccessor], map)) === null || _a === void 0 ? void 0 : _a.forEach(function (partner) {
                partner.x = currentX_1;
                partner.y = midVerticalY - partner.height / 2;
                checkContourOverlap_1.checkContourOverlap(descendantsContour, partner, settings);
                currentX_1 = getNodeRightX_1.getNodeRightX(partner);
            });
            addGroupBottomY_1.addGroupBottomY(child, settings, map);
            drillChildren(child, settings, map);
        });
    }
    else {
        var initialShiftTop = getInitialTargetsShiftTop_1.getInitialTargetsShiftTop(subtree, children, settings, map);
        var currentY_1 = subtree.y - initialShiftTop;
        children.forEach(function (child) {
            var midPointX = subtree.groupRightX + child.groupMaxWidth / 2;
            /////////////////// SIBLING
            var siblings = getFromMap_1.getFromMap(child[settings.nextBeforeAccessor], map);
            siblings === null || siblings === void 0 ? void 0 : siblings.forEach(function (sibling) {
                sibling.y = currentY_1;
                sibling.x = midPointX - sibling.width / 2;
                checkContourOverlap_1.checkContourOverlap(descendantsContour, sibling, settings);
                currentY_1 = getNodeBottomY_1.getNodeBottomY(sibling);
            });
            /////////////////// CHILD
            //Set positions
            child.y = currentY_1;
            child.x = midPointX - child.width / 2;
            checkContourOverlap_1.checkContourOverlap(descendantsContour, child, settings);
            currentY_1 = getNodeBottomY_1.getNodeBottomY(child);
            /////////////////// partners
            var partners = getFromMap_1.getFromMap(child[settings.nextAfterAccessor], map);
            partners === null || partners === void 0 ? void 0 : partners.forEach(function (partner) {
                partner.y = currentY_1;
                partner.x = midPointX - partner.width / 2;
                checkContourOverlap_1.checkContourOverlap(descendantsContour, partner, settings);
                currentY_1 = getNodeBottomY_1.getNodeBottomY(partner);
            });
            addGroupRightX_1.addGroupRightX(child, settings, map);
            drillChildren(child, settings, map);
        });
    }
    centerSourceToTargets_1.centerSourceToTargets(subtree, children, settings, map);
}
exports.drillChildren = drillChildren;
//# sourceMappingURL=drillChildren.js.map